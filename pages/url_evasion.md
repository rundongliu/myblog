title: Evade URL Detection by Using Special Character "。"
sub_title: Take Advantage of Browser's Error Checking Function
date: 2016-10-19

As a Chinese, I have two input methods in my laptop. Chinese input and
English one. As you may know, for chinese language, we use different
punctuations from English.

For example,

> 。is a full stop, equivalent to a period in Western punctuation.

Today, I am going to talk about a simple trick to evade url detection by
using “。”.

When trying to visit google today, I forgot to switch from Chinese input
method to English. “。” is generated by hitting “.” key in Chinese input
method. Then “[*http://www。google。com/*](http://www。google。com/)”
was in the url bar and I hit enter. To my surprise, chrome visited
google correctly. This is definitely not a RFC url at all, but the
connection success made me curious.

<p align="center">
<img height="196" src="https://lh5.googleusercontent.com/zs30EhuniDPToTWn4X6CoJvUHFn5zGzc6UgzYkI-LKVohYwLWRODQH60dQ98buySOENhrdH0SkPto9Hxr-ybAhnhjW54jsH1JVCb_yxCwQJGte__Pa-po9bTgCyEkinNyY6y27n9" style="-webkit-transform: rotate(0.00rad); border: none; transform: rotate(0.00rad);" width="448">
</p>

I tested “[*http://www。google。com/*](http://www。google。com/)” with
chrome, firefox, safari, wget,curl, python-urllib, java-urlconnection,
ruby-openuri, perl-LWP::Simple-get, php-file\_get\_contents.

The result is shown in the table below.
<table border="3">
<tbody>
    <tr>
        <td align="center">Software</td>
        <td align="center">Open Url Success or Not</td>
    </tr>
    <tr>
        <td align="center">chrome</td>
        <td align="center">Yes</td>
    <tr>
    <tr>
        <td align="center">IE10</td>
        <td align="center">Yes</td>
    </tr>
    <tr>
        <td align="center">firefox</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">safari</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">wget</td>
        <td align="center">Yes</td>
    </tr> 
    <tr>
        <td align="center">curl</td>
        <td align="center">Yes</td>
    </tr>
    <tr>
        <td align="center">python-urllib</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">java-urlconnection</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">ruby-openuri</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">perl-LWP::Simple-get</td>
        <td align="center">No</td>
    </tr>
    <tr>
        <td align="center">php-file\_get\_contents</td>
        <td align="center">No</td> 
    </tr>
</tbody>
</table>

As you can see in the table. The crafted url works in IE10, chrome but
not in firefox and safari.

The url works for linux command tool but does not work for any popular
programming language.

This is because every software has its own hostname parsing and
dnslookup function, so different processing method may be applied to the
same url.

Replacing “。” by “.” trick definitely makes
us Chinese lives better since we do not have to switch input method
while typing urls. But the transformation is not supported by most of
the url related software and this may cause problems when it comes to
security scanning engines.

As you know there are lots of scanning engines from security companies
running on the internet trying to detect malicious url. Some of them do
dynamic analysis by fetching contents from a url and do a content based
detection. If we can craft a malicious url that can be viewed by normal
browser but can not be detected by scanning engines, that would be a
great bypass.

The trick I mentioned above perfectly does the trick.

If a scanning tool is written in one of the programming languages or use
firefox, safari as browser emulator, crafted malicious urls can easily
bypass the scan since they can not even make a connection. After this,
when urls are passed to chrome and IE users, since browsers do the error
checking for users, users may get infected.

This method works for any url based attack.

Conclusion
==========

Some modern browsers do error checking and correction for users and make
lives easier but these tricks can also be taken advantage by malicious
attackers.

To detect crafted urls, simply do a check on the hostname of a url and
replace “。” back to “.”
